// #define TEMP (data->width * data->height)
// #define GRID_POINTS 12

// #define GRID_SIZE_X 3
// #define GRID_SIZE_Y 4
// #define GRID_POINTS 12

// #define GRID_WIDTH 3
// #define GRID_HEIGHT 4

// void draw_map(t_fdf **d)
// {
// 	t_fdf	*data = *d;
// 	t_vec2	projected_points[GRID_WIDTH * GRID_HEIGHT];
	
// 	double cube_points[GRID_HEIGHT][GRID_WIDTH][3] = {
// 		{{0, 0, 0}, {1, 0, 0}, {2, 0, 0}},
// 		{{0, 1, 0}, {1, 1, 1}, {2, 1, 0}},
// 		{{0, 2, 0}, {1, 2, 0}, {2, 2, 0}},
// 		{{0, 3, 0}, {1, 3, 0}, {2, 3, 0}},
// 	};
	
// 	// set the middle of the grid as origin
// 	t_vec3 translation = {0.5 * GRID_WIDTH, 0.5 * GRID_HEIGHT, 0};
// 	for (int y = 0; y < GRID_HEIGHT; y++) {
// 		for (int x = 0; x < GRID_WIDTH; x++) {
// 			t_vec3 point = {cube_points[y][x][0], cube_points[y][x][1], cube_points[y][x][2]};
// 			point = vec3_sub(point, translation);
// 			cube_points[y][x][0] = point.x;
// 			cube_points[y][x][1] = point.y;
// 			cube_points[y][x][2] = point.z;
// 		}
// 	}
	
// 	// apply rotation to matrix
// 	for (int y = 0; y < GRID_HEIGHT; y++) {
// 		for (int x = 0; x < GRID_WIDTH; x++) {
// 			t_vec3 point = {cube_points[y][x][0], cube_points[y][x][1], cube_points[y][x][2]};
// 			t_vec3 transformed_point = vec3_rotate_x(point, data->rotation.x);
// 			transformed_point = vec3_rotate_y(transformed_point, data->rotation.y);
// 			transformed_point = vec3_rotate_z(transformed_point, data->rotation.z);
// 			transformed_point.z -= camera_position.z;
// 			t_vec2 projected_point = project_cube(transformed_point);
// 			projected_points[y * GRID_WIDTH + x] = projected_point;
// 		}
// 	}
	
// 	// draw rectangles at projected points
// 	for (int i = 0; i < GRID_WIDTH * GRID_HEIGHT; i++) {
// 		t_vec2 projected_point = projected_points[i];
// 		draw_rect(
// 			data,
// 			projected_point.x + (WIDTH / 2),
// 			projected_point.y + (HEIGHT / 2),
// 			2,
// 			2,
// 			0xFFFFFF00
// 		);
// 	}
// }







// #define GRID_WIDTH data->width
// #define GRID_HEIGHT data->height
// #define GRID_POINTS (GRID_WIDTH * GRID_HEIGHT)

// void	draw_map(t_fdf **d)
// {
// 	t_fdf	*data;
// 	data = *d;

// 	t_vec2	projected_points[GRID_POINTS];
// 	// set the middle on the grid as origin
// 	t_vec3 translation = {0, -1, 0};
// 	for (int y = 0; y < GRID_HEIGHT; y++)
// 	{
// 	    for (int x = 0; x < GRID_WIDTH; x++)
// 	    {
// 	        t_vec3 point = data->grid[y][x];
// 			printf("%f %f %f\n", point.x, point.y, point.z);
// 	        point = vec3_sub(point, translation);
// 			printf("%f %f %f\n", point.x, point.y, point.z);
// 	        data->grid[y][x] = point;
// 			// exit(0);
// 	    }
// 	}
// 	// exit(0);
// 	for (int y = 0; y < GRID_HEIGHT; y++)
// 	{
// 	    for (int x = 0; x < GRID_WIDTH; x++)
// 	    {
// 	        t_vec3 point = data->grid[y][x];
	
// 	        t_vec3 transformed_point = vec3_rotate_x(point, data->rotation.x);
// 	        transformed_point = vec3_rotate_y(transformed_point, data->rotation.y);
// 	        transformed_point = vec3_rotate_z(transformed_point, data->rotation.z);
	
// 	        transformed_point.z -= camera_position.z;
	
// 	        t_vec2 projected_point = project_cube(transformed_point);
// 	        projected_points[y * GRID_WIDTH + x] = projected_point;
// 	    }
// 	}
	
// 	for (int y = 0; y < GRID_HEIGHT; y++)
// 	{
// 	    for (int x = 0; x < GRID_WIDTH; x++)
// 	    {
// 	        t_vec2 projected_point = projected_points[y * GRID_WIDTH + x];
	
// 	        draw_rect(
// 	            data,
// 	            projected_point.x + (WIDTH / 2),
// 	            projected_point.y + (HEIGHT / 2),
// 	            2,
// 	            2,
// 	            0xFFFFFF00
// 	        );
// 	    }
// 	}
// }

// void	draw_map(t_fdf **d)
// {
// 	t_fdf	*data;
// 	data = *d;

// 	t_vec2	projected_points[GRID_POINTS];
// 	t_vec3 cube_points[GRID_HEIGHT][GRID_WIDTH] = {
//     { { 0,  0,  0}, { 1,  0,  0}, { 2,  0,  0} },
//     { { 0,  1,  0}, { 1,  1,  1}, { 2,  1,  0} },
//     { { 0,  2,  0}, { 1,  2,  0}, { 2,  2,  0} },
//     { { 0,  3,  0}, { 1,  3,  0}, { 2,  3,  0} },
// 	};

// 	// set the middle on the grid as origin
// 	t_vec3 translation = {0, 0, 0};
// 	for (int y = 0; y < GRID_HEIGHT; y++)
// 	{
// 	    for (int x = 0; x < GRID_WIDTH; x++)
// 	    {
// 	        t_vec3 point = cube_points[y][x];
// 	        point = vec3_sub(point, translation);
// 	        cube_points[y][x] = point;
// 	    }
// 	}

// 	for (int y = 0; y < GRID_HEIGHT; y++)
// 	{
// 	    for (int x = 0; x < GRID_WIDTH; x++)
// 	    {
// 	        t_vec3 point = cube_points[y][x];
	
// 	        t_vec3 transformed_point = vec3_rotate_x(point, data->rotation.x);
// 	        transformed_point = vec3_rotate_y(transformed_point, data->rotation.y);
// 	        transformed_point = vec3_rotate_z(transformed_point, data->rotation.z);
	
// 	        transformed_point.z -= camera_position.z;
	
// 	        t_vec2 projected_point = project_cube(transformed_point);
// 	        projected_points[y * GRID_WIDTH + x] = projected_point;
// 	    }
// 	}
	
// 	for (int y = 0; y < GRID_HEIGHT; y++)
// 	{
// 	    for (int x = 0; x < GRID_WIDTH; x++)
// 	    {
// 	        t_vec2 projected_point = projected_points[y * GRID_WIDTH + x];
	
// 	        draw_rect(
// 	            data,
// 	            projected_point.x + (WIDTH / 2),
// 	            projected_point.y + (HEIGHT / 2),
// 	            2,
// 	            2,
// 	            0xFFFFFF00
// 	        );
// 	    }
// 	}
// }


















// void	draw_map(t_fdf **d)
// {
// 	t_fdf	*data;
// 	data = *d;
// 	t_vec2	projected_points[GRID_POINTS];
// 	t_vec3 cube_points[GRID_POINTS] = {
// 		{ 0,  0,  0},	// vertex 0
// 		{ 1,  0,  0},	// vertex 0
// 		{ 2,  0,  0},	// vertex 0
// 		{ 0,  1,  0},	// vertex 0
// 		{ 1,  1,  1},	// vertex 0
// 		{ 2,  1,  0},	// vertex 0
// 		{ 0,  2,  0},	// vertex 0
// 		{ 1,  2,  0},	// vertex 0
// 		{ 2,  2,  0},	// vertex 0
// 		{ 0,  3,  0},	// vertex 0
// 		{ 1,  3,  0},	// vertex 0
// 		{ 2,  3,  0},	// vertex 0
// 	};
// 	//	sets the midel on the grid as origin
// 	// t_vec3 translation = {1, 1, 0};
// 	t_vec3 translation = {0, 0, 0};
// 	for (int i = 0; i < GRID_POINTS; i++)
// 	{	
// 		t_vec3 point = cube_points[i];
// 		point = vec3_sub(point, translation);
// 		cube_points[i] = point;
// 		// printf("%f, %f, %f\n", cube_points[i].x, cube_points[i].y, cube_points[i].z);
// 	}
// 	// aply rotation to matrix
// 	for (int i = 0; i < GRID_POINTS; i++)
// 	{
// 		t_vec3	point = cube_points[i];

// 		t_vec3	transformed_point = vec3_rotate_x(point, data->rotation.x);
// 		transformed_point = vec3_rotate_y(transformed_point, data->rotation.y);
// 		transformed_point = vec3_rotate_z(transformed_point, data->rotation.z);

// 		transformed_point.z -= camera_position.z;

// 		t_vec2	projected_point = project_cube(transformed_point);
// 		projected_points[i] = projected_point;
// 		// printf("%f, %f\n", projected_points[i].x, projected_points[i].y);
// 	}
// 	for (int i = 0; i < GRID_POINTS; i++)
// 	{
// 		t_vec2 projected_point = projected_points[i];
// 		printf("%f, %f\n", projected_point.x, projected_point.y);
// 		draw_rect(
// 			data,
// 			projected_point.x + (WIDTH / 2),
// 			projected_point.y + (HEIGHT / 2),
// 			2,
// 			2,
// 			0xFFFFFF00
// 		);
// 	}
// }






















// void	draw_map(t_fdf **d)
// {
// 	t_fdf	*data;
// 	data = *d;
// 	t_vec2	projected_points[TEMP];
// 	t_vec2	**transformed_map;
// 	transformed_map = ft_calloc(sizeof(t_vec2 *), data->height + 1);

// 	// return ;
// 	// printf("TEMP = %d\n", TEMP);
	
// 	//	sets the midel on the grid as origin
// 	t_vec3 translation = {1.5, 1.5, -.5};
// 	for (int y = 0; y < data->height; y++)
// 	{	
// 		for (int x = 0; x < data->width; x++)
// 		{
// 			t_vec3 point = data->grid[y][x];
// 			point = vec3_sub(point, translation);
// 			data->grid[y][x] = point;
// 			// printf("%f, %f,  %f\n", data->grid[y][x].x, data->grid[y][x].y, data->grid[y][x].z);
// 		}
// 		// printf("\n");
// 	}
// 	// aply rotation to matrix
// 	// for (int y = 0; y < data->height; y++)
// 	// {	
// 	// 	for (int x = 0; x < data->width; x++)
// 	// 	{
// 	// 		t_vec3	point = data->grid[y][x];

// 	// 		t_vec3	transformed_point = vec3_rotate_x(point, data->rotation.x);
// 	// 		transformed_point = vec3_rotate_y(transformed_point, data->rotation.y);
// 	// 		transformed_point = vec3_rotate_z(transformed_point, data->rotation.z);
	
// 	// 		transformed_point.z -= camera_position.z;
	
// 	// 		t_vec2	projected_point = project_cube(transformed_point);
// 	// 		projected_points[y * data->width + x] = projected_point;
// 	// 		printf("%f, %f\n", projected_point.x, projected_point.y);
// 	// 	}
// 	// }

// 	for (int y = 0; y < data->height; y++)
// 	{	
// 		transformed_map[y] = ft_calloc(sizeof(t_vec2), data->height + 1);
// 		for (int x = 0; x < data->width; x++)
// 		{
// 			t_vec3	point = data->grid[y][x];

// 			t_vec3	transformed_point = vec3_rotate_x(point, data->rotation.x);
// 			transformed_point = vec3_rotate_y(transformed_point, data->rotation.y);
// 			transformed_point = vec3_rotate_z(transformed_point, data->rotation.z);
	
// 			transformed_point.z -= camera_position.z;
	
// 			t_vec2	projected_point = project_cube(transformed_point);
// 			projected_points[y * data->width + x] = projected_point;
// 			transformed_map[y][x] = projected_point;
// 			printf("%f, %f\n", projected_point.x, projected_point.y);
// 		}
// 	}

// 	for (int y = 0; y < data->height; y++)
// 	{	
// 		for (int x = 0; x < data->width; x++)
// 		{
// 			t_vec2 projected_point = transformed_map[y][x];
// 			draw_rect(
// 				data,
// 				projected_point.x + (WIDTH / 2),
// 				projected_point.y + (HEIGHT / 2),
// 				2,
// 				2,
// 				0xFFFFFF00
// 			);
// 		}
// 	}
	
// 	// draws rectangles on the projected points
// 	// int i = 0;
// 	// for (int i = 0; i < TEMP; i++)
// 	// {
// 	// 	t_vec2 projected_point = projected_points[i];
// 	// 	// printf("%f, %f\n", projected_point.x, projected_point.y);
// 	// 	draw_rect(
// 	// 		data,
// 	// 		projected_point.x + (WIDTH / 2),
// 	// 		projected_point.y + (HEIGHT / 2),
// 	// 		2,
// 	// 		2,
// 	// 		0xFFFFFF00
// 	// 	);
// 	// }
// 	return ;
// }